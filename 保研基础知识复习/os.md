# OS



### [衡量cache的性能的标准？（命中率）](https://zhuanlan.zhihu.com/p/35303026)
- 什么是Cache

cache是一个硬件或软件的组件用来存储将来会请求到的数据，而且能让数据获取更快。因为如今缓存的概念已被扩充，不仅在CPU和主内存之间有Cache，而且在内存和硬盘之间也有Cache（磁盘缓存），乃至在硬盘与网络之间也有某种意义上的Cache──称为Internet临时文件夹或网络内容缓存等。凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为Cache。

一般而言，高速缓存（cache）是一个小而快的存储设备，它作为存储在更大也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程成为缓存（caching）。**cache的效率由命中率来衡量**，一个好的cache效率通常在80%-95%的命中率。

- 缓存命中和不命中
1. 缓存命中
在存储器层次结构中，假设层次从上到下是增序排列，假设一个k值，当程序需要第k+1层的某个数据对象d时，它首先在第k层的一块中查找d，如果d刚好缓存在k层中，就是缓存命中(cache hit).
2. 缓存不命中
当在k层找不到数据d时，我们就称k层缓存不命中(cache miss)。当发生缓存不命中的时候，第k层缓存从第k+1层缓存中取出包含d的那个块，如果k层缓存满了，就会覆盖现有的块。
覆盖一个现存的块的过程称为替换(replacing)或驱逐(evicting)这个块。被驱逐的块称为牺牲(victim)块。关于替换哪个具体的块是由替换策略来控制的。比如随机替换策略，或最少最近被使用策略(LRU)

- LRU（least Recently use）算法：

缓存不命中的种类

**强制不命中或冷不命中**：这种不命中是由于缓存是空的，它通常是短暂的，不会在反复访问存储器的过程中出现。

**冲突不命中**：这种缓存是由于放置策略引起的。如下图所示，如果程序请求0，然后8，然后0，然后8，就会出现每次都不命中

**容量不命中**：当工作集的大小超过了缓存的大小的时候，不能处理这个工作集，就会发生容量不命中。

- 替换策略

上文提到，覆盖一个现存的块的时候会使用替换策略，替换策略有很多种，主要有：

LRU - Least Recently Used
通常用于组相联高速缓存，会有一个age counter（替换index）与每个数组S相关。这个counter最大值就是S，当一个set被访问到，那么比它低的counter就被置为0，其他set自增1。举个例子，有4个set的缓存，原本的counter值是0-3-2-1，如果第三个被访问到了，那么counter的值是1-3-0-2。

FIFO - First-In First-Out
先进先出策略，通常用于组相联高速缓存。

LFU – Least Frequently Used
很高效的算法，但很耗资源，通常不用。

Round-robin
用于全相联高速缓存。有一个指针指向将要被替换的行，当行被替换，指针就会自增1，指针是环形的。

Random
随机策略，用于全相联高速缓存。每个时序Round-robin就要更新，而不是每个替换操作。

- 回写策略

cache的回写策略决定怎么把cache的数据写到内存的位置中去。有两种基本的策略：

写回（write back）
写回是指，仅当一个缓存块需要被替换回内存时，才将其内容写入内存。如果缓存命中，则总是不用更新内存。为了减少内存写操作，缓存块通常还设有一个脏位（dirty bit），用以标识该块在被载入之后是否发生过更新。如果一个缓存块在被置换回内存之前从未被写入过，则可以免去回写操作。写回的优点是节省了大量的写操作。这主要是因为，对一个数据块内不同单元的更新仅需一次写操作即可完成。这种内存带宽上的节省进一步降低了能耗，因此颇适用于嵌入式系统。

写通（write through）
写通是指，每当缓存接收到写数据指令，都直接将数据写回到内存。如果此数据地址也在缓存中，则必须同时更新缓存。由于这种设计会引发造成大量写内存操作，有必要设置一个缓冲来减少硬件冲突。这个缓冲称作写缓冲器（Write buffer），通常不超过4个缓存块大小。不过，出于同样的目的，写缓冲器也可以用于写回型缓存。
写通较写回易于实现，并且能更简单地维持数据一致性。


### 处理器管理。包括进程控制、进程互斥等[参考资料](https://blog.csdn.net/qq_29053423/article/details/105138685)

**1. 进程控制**

进程控制的主要任务就是为程序创建进程，撤销已结束的进程，以及控制进程在运行过程中的状态转换。在操作系统中，通常是利用若干条进程控制原语或系统调用，来实现进程的控制。所谓“原语”是指用以完成特定功能的、具有“原子性”的一个过程。

**1.2. 进程同步**
进程同步的主要任务是对众多的进程运行进行协调。

协调方式有两种：

（1）进程互斥方式
进程在对临界资源访问时，应采用互斥方式，也就是当一个进程访问临界资源时，另一个要访问该临界资源的进程必须等待；当获取临界资源的进程释放临界资源后，其他进程才能获取临界资源。这种进程之间的相互制约关系称为互斥。

对于进程互斥，最简单的实现方式就是设置锁，通过加锁、解锁实现互斥。

（2）进程同步方式
 相互合作的进程，由同步机构对它们的执行次序加以协调。也就是前一个进程结束，后一个进程才能开始；前一个进程没有结束，后一个进程就不能开始。**这种进程之间的相互合作关系称为同步。**

在系统中，进程的同步可以有多种实现方法，其中，最常用的方法是信号量机制。

**1.3. 进程通信**

进程通信的任务就是用来实现相互合作进程之间的信息交换。

（1）直接通信方式
当相互合作的进程处于同一台计算机系统时，通常采用直接通信方式。由源进程利用发送命令直接将消息发送到目标进程的消息队列上，然后由目标进程利用接收命令从其消息队列中取出消息。

（2）间接通信方式
当相互合作的进程处于不同计算机系统时，通常采用间接通信方式。由源进程利用发送命令将信息发送到一个专门存放消息的中间实体中，然后由目标进程利用接收命令从中间实体中取出消息。这个中间实体通常称为“邮箱”，相应的通信系统称为电子邮件系统。

**1.4. 处理器调度**

一个批处理作业从进入系统并驻留在外存的后备队列上开始，直至作业运行完毕，可能要经历下述三级调度。

（1）高级调度
它又称为作业调度、长程调度或宏观调度，它的功能是按照某种原则把外存上处于后备队列中的那些作业调入内存，并为它们创建进程、分配必要的资源，然后再将新创建的进程排在就绪队列上，准备执行。

在批处理系统中有高级调度，而在分时系统中一般无高级调度。

（2）低级调度
它通常又称进程调度、短程调度或微观调度，它的功能是按照某种原则决定就绪队列中的哪个进程应获得处理机，再由分配程序执行处理机分配给该进程的具体动作。

进程调度是操作系统中最基本的调度，在批处理系统和分时系统中都必须配置它。

（3）中级调度
中级调度又称中程调度或交换调度。它负责内外存之间的进程对换，以解决内存紧张的问题，提高内存利用率和系统吞吐量。
![三种处理器调度的关系：](img/os/os-2020-07-19-16-05-37.png)

二、程序执行
程序执行是指程序在计算机中的运行过程。程序的执行可以用前趋图表示，程序的执行方式有顺序执行和并发执行两种。

1. 前趋图
前趋图是一个有向无循环图。图中的每个节点可用于表示一条语句、一个程序段等；节点间的有向边表示在两个节点之间存在的前趋关系。如Pi→Pj，称Pi是Pj的前趋，而Pj是Pi的后继。在前趋图中，没有前趋的节点称为初始节点，没有后继的节点称为终止节点。应当注意的是，前趋图中不能存在循环。

 ![](img/os/os-2020-07-19-16-23-00.png)

在上图所示的前趋图中存在下述前趋关系：

    P1→P2，P1→P3，P2→P4，P3→P4，P4→P5。

2. 程序的顺序执行
（1）程序顺序执行的概念
一个程序通常可分为多个程序段，它们必须按照某种先后次序执行，仅当前一操作执行完后，才能执行后继操作。这里，我们用结点（Node）代表各程序段的操作，用I代表输入操作，C为计算操作，P为打印操作，用箭头表示其操作顺序 
![](img/os/os-2020-07-19-16-24-16.png)


（2）程序顺序执行的特征

①顺序性。严格按照程序所规定的顺序执行。

②封闭性。程序在封闭的环境下执行，其执行结果不受外界因素的影响。

③确定性。程序执行的结果与它的执行速度无关，不会影响到最终结果。

④可再现性。只要程序执行的环境和初始条件相同，都将获得相同的结果。

3. 程序的并发执行
（1）程序并发执行的概念
在处理一批程序时，它们之间有时并不存在严格的执行次序，可以并发执行。

程序并发执行时的前趋图，如下图所示。
![](img/os/os-2020-07-19-16-24-43.png)

Ｉ２、Ｃ１可以并发执行

Ｉ３、Ｃ２、Ｐ１可以并发执行。

对于具有下述四条语句的程序段：

         S1： a ：＝x十2

          S2：b：=y十4

          S3：c：=a十b

          S4：d：＝c＋b

四条语句的前趋图：
![](img/os/os-2020-07-19-16-25-07.png)

（2）程序并发执行的特征
①间断性。在程序并发执行时，它们之间共享资源或相互合作，形成了相互制约的关系，表现为“执行—暂停执行—执行”的间断性活动规律。

②失去封闭性。程序并发执行时，多个程序共享系统中的各种资源，致使程序的运行失去了封闭性。这样，一个程序在执行时，必然会受到其他程序的影响。

③不可再现性。即使并发程序执行的环境和初始条件相同，程序多次执行或以不同的方式执行都可能获得不相同的结果。

④资源共享性。系统中的硬件资源（CPU、内存和I/O设备等）和软件资源（系统程序和数据集等）为多个用户或作业共同使用。

⑤程序和计算不再一一对应。

**4.并发与顺序的比较**

![](img/os/os-2020-07-19-16-25-56.png)

### 操作系统线程跟进程的区别等:

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。

进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.

2) 线程的划分尺度小于进程，使得多线程程序的并发性高。

3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

**简洁明了版：**

- 进程是运行中的程序，线程是进程的内部的一个执行序列
- 进程是资源分配的单元，线程是执行的单元
- 进程间切换代价大，线程间切换代价小
- 进程拥有资源多，线程拥有资源少
- 多个线程共享进程的资源
- 比喻的说话：

开个QQ，开了一个进程；开了迅雷，开了一个进程。

在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。

所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”分别有一个线程。

所以一个进程管着多个线程。


### 存储管理。包括分区存储、页式存储等。

### 文件管理。包括文件目录、文件系统的实现等。