## 算法：
LRU( Least Recently Used)缓存淘汰算法： [链接](https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/)

### 图的知识：

生成树： 两种生成办法：
1. DFS（Depth-first search）深度优先搜索
访问第一个孩子节点。一直找到没有孩子节点。然后再找第二个孩子节点。

2. BFS（Breath-first Search) 广度优先搜索 

从根节点开始，沿着树的宽度遍历树的节点，如果发现目标，则演算终止。

先访问所有子节点，然后访问结束之后，第一个子节点的字节点。
时间复杂度：邻接表的时候是O(|V| + |E|)

**连通图**：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。

**强连通图**：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。

**连通网**：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。

**生成树**：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。

- **最小生成树**：在连通网的所有生成树中，所有边的代价之和最小的生成树，称为最小生成树。

- **Prim算法**：在边较多时适用 密集图

在一个加权连通图中，顶点集合V，边集合为E
1. 任意选出一个点作为初始顶点,标记为visit,计算所有与之相连接的点的距离，选择距离最短的边，标记visit.
2. 在剩下的点中，计算与已标记visit点距离最小的点，标记visit,证明加入了最小生成树，将边记录。重复以上操作，直到所有点都被标记为visit。

- **Kruskal算法**：稀疏图 边少的时候用

1. 把图中的所有边按代价从小到大排序；
2. 把图中的n个顶点看成独立的n棵树组成的森林；
3. 按权值从小到大选择边，所选的边连接的两个顶点ui,,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。
4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。

- 最短路径问题：

