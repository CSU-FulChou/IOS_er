## 算法：
LRU( Least Recently Used)缓存淘汰算法： [链接](https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/)

## 基础知识[学习资料网站链接](https://blog.csdn.net/weixin_40113925/article/details/100938378)：
### 2 线性结构：

#### 2.1 线性表：
**顺序表** ：线性表的顺序存储结构，数组。内存连续，构造简单，可随机存取O(1)，按下标访问。插入和删除需平移节点，时间复杂度O(n)。表的容量需事先确定，容易造成内存碎片。

线性链表 ：单链表。用一组任意的不一定连续的存储单元来依次存放线性表的结点。

  每个结点包含两个域：data域是数据域，用来存放结点的值。next是指针域，用来存放结点的直接后继的地址。不需要事先估计存储空间大小。

  第一个节点无前驱，用头指针HEAD指向开始节点/第一个节点。

  最后节点无后继，指向空指针NULL。

建表：头插法建表(逆序)、尾插法建表(顺序)。

查找 ：从head出发直到第i个节点。链表不是随机存取结构。

插入 ：先找到表的第i-1的存储位置，然后插入。新结点先连后继再连前驱。O（n）

删除 ：先找前驱p。然后令p–&gt;next指向ai的直接后继结点，即把ai从链上摘下。最后释放结点ai的空间.r=p-&gt;next;p-&gt;next=r-&gt;next;delete r。

**静态链表** ：用一维数组来实现线性链表。容量是一定的。静态链表中指针表示的是下一元素在数组中的位置。是顺序的存储结构。静态链表在插入、删除时也是通过修改指针域来实现的。

**循环链表** ：是一种头尾相接的链表。其特点是无须增加存储量，仅对表的链接方式稍作改变，即可使得表处理更加方便灵活。

**判断一个单向链表中是否存在环的最佳方法是 快慢指针**

涉及遍历操作时，其终止条件变为判断它们是否等于某一指定指针，如头指针或尾指针等。

**双向链表** :在单链表的每个结点里再增加一个指向其直接前趋的指针域prior。这样就形成的链表中有两个方向不同的链。双链表一般由头指针唯一确定的，将头结点和尾结点链接起来构成循环链表，并称之为双向链表。在有序双向链表中定位删除一个元素的平均时间复杂度为O(n),但是若指定节点，则可以直接删除当前指针所指向的节点。而不需要像单向链表中，删除一个元素必须找到其前驱。

#### 2.2 栈：

栈(Stack)是限制在表的一端进行插入和删除运算的线性表，通常称插入、删除的这一端为栈顶(Top)，另一端为栈底(Bottom)。后进先出。

顺序栈 ：顺序存储结构。top= -1时为空栈，top=0只能说明栈中只有一个元素，并且元素进栈时top应该自增

链栈 ：链式存储结构。插入和删除操作仅限制在链头位置上进行。栈顶指针就是链表的头指针。通常不会出现栈满的情况。 不需要判断栈满但需要判断栈空。

基本操作：删除栈顶元素、判断栈是否为空以及将栈置为空栈等

对于n各元素的入栈问题，可能的出栈顺序有C(2n,n)/(n+1)个。（卡特兰数）

判定出栈顺序是否成立：在某个数字后，所有比此数字小的数字应降序排列？？？


堆栈溢出一般是循环的递归调用、大数据结构的局部变量导致的

经典应用 ：进制转换、括号匹配、迷宫求解、表达式求解：用于求解中缀表达式或者在前缀、中缀、后缀表达式间进行转换。

利用栈实现中缀转后缀：从左向右扫描中缀，遇到数字则加入后缀表达式，遇到运算符：
1. 若是（则入栈 
2. 若是）则从栈中弹出运算符直到（ 
3. 若是其他，则从栈中依次弹出优先级大于等于他的运算符，若遇到（则停止，然后将他入栈。

在后缀表达式中（）不出现

实现递归：多个函数嵌套调用的规则是：后调用先返回。

不是所有的递归程序都需要栈来保护现场，比方说求阶乘的，是单向递归，直接用循环去替代从1乘到n就是结果了，另外一些需要栈保存的也可以用队列等来替代。不是所有的递归转化为非递归都要用到栈。转化为非递归主要有两种方法：对于尾递归或单向递归，可以用循环结构算法代替




### 图的知识：

生成树： 两种生成办法：
1. DFS（Depth-first search）深度优先搜索
访问第一个孩子节点。一直找到没有孩子节点。然后再找第二个孩子节点。

2. BFS（Breath-first Search) 广度优先搜索 

从根节点开始，沿着树的宽度遍历树的节点，如果发现目标，则演算终止。

先访问所有子节点，然后访问结束之后，第一个子节点的字节点。
时间复杂度：邻接表的时候是O(|V| + |E|)

**连通图**：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。

**强连通图**：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。

**连通网**：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。

**生成树**：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。

- **最小生成树**：在连通网的所有生成树中，所有边的代价之和最小的生成树，称为最小生成树。

- **Prim算法**：在边较多时适用 密集图

在一个加权连通图中，顶点集合V，边集合为E
1. 任意选出一个点作为初始顶点,标记为visit,计算所有与之相连接的点的距离，选择距离最短的边，标记visit.
2. 在剩下的点中，计算与已标记visit点距离最小的点，标记visit,证明加入了最小生成树，将边记录。重复以上操作，直到所有点都被标记为visit。

- **Kruskal算法**：稀疏图 边少的时候用

1. 把图中的所有边按代价从小到大排序；
2. 把图中的n个顶点看成独立的n棵树组成的森林；
3. 按权值从小到大选择边，所选的边连接的两个顶点ui,,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。
4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。

- 最短路径问题：




